## 代码整洁之道

### 1.整洁代码

沼泽（糟糕的代码）：我们趟过代码的水域，穿过灌木密布、瀑布暗藏的沼泽地，我们拼命想找到出路，期望有点什么线索能启发我们到底发生了什么事；但目光所及，只是越来越多死气沉沉的代码。  
稍后 等于 永不(later equals never)

### 4.注释

注释的恰当用法是弥补我们用代码表达意图时遭遇的**失败**  
注释是一种失败，因为无法找到不用注释就能表达自我的方法  
不准确的注释比没注释坏的多。它们满口胡言，它们预期的东西不能实现，它们设定了无需也不应再遵守的旧规则。  
真实只在一处地方有：代码。只有代码能忠实的告诉你它做的事，那是唯一真正准确的信息来源。

#### 4.1 注释不能美化糟糕的代码

与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那堆糟糕的代码

#### 4.2 用代码来阐述

用代码解释意图(或许需要创建一个描述与注释所言同一事物的函数)

#### 4.3 好的注释

开头放置版权及著作权声明  
注释可以用来提供基本信息（返回值） 对意图进行解释  
阐释：将某些晦涩难懂的参数或返回值的意义翻译成某种可读的形式  
警告其他人会出现某种后果  
// TODO 展示一些认为应该做，但由于某些原因还没做的工作

#### 4.4坏注释

喃喃自语、多余的注释、误导性注释、循规式注释、日志式注释、废话注释  
能用函数或变量时别用注释、不用注释进行位置标记、不注释代码(直接删除)  
注释靠近代码、信息不要太多、函数名 > 注释

### 5.格式

当有人查看底层代码实现时，我们希望他们为整洁、一致及所感知到的对细节的关注而震惊。我们希望他们高高扬起眉毛，一路看下去。我们希望他们感受到那些为之劳作的专业人士们。但若他们看到的只是一堆像是由醉酒的水手写出的鬼画符，那他们多半会得出结论，认为项目其他任何部分也同样对细节漠不关心。

#### 5.1格式的目的

你今天编写的功能，既有可能再下一版本被修改，但代码的可读性却会对以后可能发生的修改行为产生深远影响。原始代码修改之后很久，其代码风格和可读性仍会影响到可维护性和扩展性。即便代码不复存在，你的风格和律条仍存活下来。

短文件  
垂直方向上的区隔(不同方法之间等增加空白行)  
关系紧密的变量之间靠近  
变量的上面要靠近使用  
循环中的控制变量应在循环语句中声明  
本地变量放于顶部  
函数调用者放在被调用者上方  
概念相关(执行相似操作)的代码放到一起  
横向字符数量 < 120

### 6.对象和数据结构

对象隐藏数据，暴露操作

过程式编程(使用数据结构的代码)便于在不改动现有数据结构的前提下添加新函数  
面向对象代码便于在不该打现有函数的前提下添加新类

过程式代码难以添加新数据结构，因为必须修改所有函数  
面向对象代码难以添加新函数，因为必须修改所有的类

#### 得墨忒定律

模块不应了解它所操作对象的内部情形  
类C的方法f只应该调用以下方法：

* C
* 由f创建的对象
* 作为参数传递给f的对象
* 由C的实体变量持有的对象

对象暴露行为，隐藏数据。便于添加新对象类型而无需修改既有规则，同时难以在既有对象中添加新行为。  
数据结构暴露数据，没有明显的行为。便于向现有数据结构中添加新行为，难以向既有函数中添加新数据结构。

### 7.错误处理

错误处理代码不能搞乱代码逻辑

#### 7.1使用异常而非返回码

#### 7.2先写try-catch-finally语句

#### 7.3使用未受检异常

可控异常(CheckedException)违反开放/闭合原则。如果在方法中抛出受检异常，需要在catch语句和抛出异常处的每个方法签名中声明该异常。  
意味着对软件中较低层级的修改，都将波及较高层级的签名。修改好的模块必须重新构建、发布，及时他们自身关注的任何都行都没改动过。  
最终得到一个从软件底层贯穿到最高端的修改链，封装被打破了，因为在抛出路径的每个函数中都要去了解下一层级的异常细节。

#### 7.4给出异常发生的环境说明

e.printStackTrace()

#### 7.5依调用者需要定义异常

将第三方库API中的多个异常打包，抛出一个自定义的异常，降低对第三方的耦合性

#### 7.6定义常规流程

特例模式(special case pattern)，创建一个类或配置一个对象，用来处理特例  
客户代码不用处理异常行为，将异常封装到特例对象中

#### 7.7别返回、传递null

### 8边界

### 9单元测试

#### 9.1 测试驱动开发 TDD

编写生产代码之前先编写单元测试

1. 在编写不能通过的单元测试前，不可编写生产代码
2. 只可编写刚好无法通过的单元测试，不能编译也算不通过
3. 只可编写刚好足以通过当前失败测试的生产代码

测试代码和生产代码一样重要。它需要被思考、被设计和被照料。它该像生产代码一样保存整洁。  
如果测试不能保持整洁，你就会失去他们。没有测试，你就会失去保证生产戴拿可扩展的一切要素。正是单元测试让代码可扩展、可维护、可复用。  
如果你坐视测试腐坏，那么代码也会跟着腐坏。  
有了测试，就不必担心对代码的修改；没有测试，每次修改都可能带来缺陷。

#### 9.3整洁的测试

可读性：明确，简洁，有足够的表达力  
构造测试数据、操作测试数据、检验操作是否得到期望的结果  
测试代码 和 生产代码 可以有双重标准，通常这关乎CPU效率问题，不过永远不会与整洁有关  
每个单元测试的断言最小化  
快速fast 测试应该运行够快  
独立independent 测试之间互相独立，不能互相依赖，某个测试不应为下个测试设定条件  
可重复repeatable 测试应该可以在任何环境中重复通过  
自足验证self-validating 测试应该有布尔值输出，不要目测结果  
及时timely 测试应及时编写

### 10.类

#### 10.1类的组织

公告静态变量、私有静态变量、私有实体变量、公共变量，公共函数  
private default protected public  
(类内部、同一个包、子类、任何地方)  
类应该短小：类的名称描述其权责，类名字不包含意义模糊的词  
单一权责原则 (single responsibility principle) 一个类只能有一个引起它变化的原因  
系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并于少数其他类一起协同达成期望的系统行为。  
内聚：类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种变量。  
方法操作的变量越多，就越黏聚到类上。如果类中的每个变量都被每个方法使用，则该类具有最大的内聚性。  
内聚性越高意味着类中的方法和变量互相依赖、互相结合成一个逻辑整体。  
使用抽象类和接口隔离细节带来的影响。  
依赖倒置原则 (dependency inversion principle) 类应该依赖于抽象而不依赖于具体实现

### 11.系统

#### 11.1将系统的构造和使用分开

#### 11.2分解main方法

将全部的构造过程放到main方法中  





















